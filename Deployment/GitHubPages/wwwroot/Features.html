<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Features</title>
    <link rel="stylesheet" href="stylesheet.css">
</head>
<body class="dynamic-content-body">
    <h2>Features</h2>

    <p class="indented-p">
        <i>Hazard!</i> implements an MVVM architecture, diagrammed below. It's packaged and deployed as an .MSIX bundle using WAPP.
        It's built, signed, hosted, and secured using Azure Pipelines, Trusted Signing, Blob Storage, an Azure Function, and a WebApp which is, finally,
        connected to this site!
    </p>
    <p class="indented-p">
        The Model and Shared projects feature Unit Tests (see the
        <a href="https://github.com/LivingCryogen/Hazard#hazard" class="external-link">ReadMe</a>
        for build instructions), and<a href="docs.html" class="external-link"> .XML documentation</a>, integrating with Intellisense.

    <p class="indented-p">For Feature highlights, see below, and check out the <a href="" class="external-link">Demo</a> video.</p>

    <p class="indented-p">
        For full details see the <a href="https://github.com/LivingCryogen/Hazard" class="external-link">Repo</a>, or even try running it for yourself!
        [ <a href="https://hazardgameproxy-d4caecgsapakcwh0.centralus-01.azurewebsites.net/secure-link?arch=x64" class="external-link">Download(x64)</a>
        <a href="https://hazardgameproxy-d4caecgsapakcwh0.centralus-01.azurewebsites.net/secure-link?arch=ARM" class="external-link">Download(ARM)</a> ]
    </p>
    <h3>Runtime Architecture</h3>
    <div class="image-with-text" style="margin-left:6em; margin-right: 2em;">
        <div class="image-text">
            <br />
            <h3>
                Model-ViewModel-View (MVVM)
            </h3>
            <ul>
                <li><strong>Model -</strong> Core game logic and state.</li>
                <li><strong>ViewModel -</strong> Mediates between Model and View.</li>
                <li><strong>View -</strong> WPF UI.</li>
                <li><strong>Shared -</strong> Interfaces, globals, and shared services.</li>
                <li><strong>BootStrap -</strong> Entry point, dependency injection and environment and configuration.</li>
            </ul>
        </div>
        <img src="Images/runtime-architecture.svg" style="max-width:550px; height: auto;" />
    </div>
    <br />

    <h2>Technical Feature Highlights</h2>

    <h4>Note: Code Snippets below omit documentation comments and some code.</h4>

    <div class="code-with-text" id="EventSystem">
        <div class="image-text">
            <img src="Images/Events.svg" />
            <h3>State-Driven Event System</h3>
            <p class="indented-p">At <i>Hazard!</i>'s core is a regulated state machine. It manages flow between phases (Setup, Place, Attack, Move), with proper state transitions and validation.</p>
            <p class="indented-p">Rather than tight coupling, we rely on an event system that propagates changes correctly while maintaining separation of concerns:</p>
            <ul>
                <li>State changes trigger appropriate events</li>
                <li>Subscribers respond to state changes without direct dependencies</li>
                <li>Player actions and game rules are separated</li>
                <li>Phases with multi-stage actions are handled</li>
                <li>Turn and round progression are managed automatically</li>
                <li>Clean architecture - DI manages component lifetimes and subscription cleanup, while synchronous game logic eliminates threading concerns</li>
            </ul>
            <p><center><i>Key Files: StateMachine, Regulator, MainVM_Base, et al.</i></center></p>
        </div>
        <div>
            <pre class="code-snippet">
            <code class="language-csharp">
// StateMachine.cs - Core state management with event propagation
public class StateMachine : IBinarySerializable
{
    private readonly ILogger<StateMachine> _logger; // ... constructor and other fields omitted
    private GamePhase _currentPhase = GamePhase.Null;
    private bool _phaseStageTwo = false;
    private int _playerTurn = 0;
    private int _round = 0;
    // ... _numTrades and other properties omitted

    // Event system for loose coupling
    public event EventHandler<string>? StateChanged;

    public GamePhase CurrentPhase {
        get { return _currentPhase; }
        set {
            if (!value.Equals(_currentPhase)) {
                _currentPhase = value;
                StateChanged?.Invoke(this, new(nameof(CurrentPhase)));
            }
        }
    }

    public bool PhaseStageTwo {
        get { return _phaseStageTwo; }
        set {
            if (!value.Equals(_phaseStageTwo)) {
                _phaseStageTwo = value;
                StateChanged?.Invoke(this, new(nameof(PhaseStageTwo)));
            }
        }
    }

    public int PlayerTurn {
        get { return _playerTurn; }
        set {
            if (!value.Equals(_playerTurn)) {
                _playerTurn = value;
                StateChanged?.Invoke(this, new(nameof(PlayerTurn)));
            }
        }
    }

    // Automated state progression
    public void IncrementPhase()
    {
        PhaseStageTwo = false;
        int intPhase = (int)CurrentPhase;
        if (intPhase >= 0 && intPhase < 3) // Place (1) -> Attack (2) -> Move (3)
        {
            intPhase++;
            CurrentPhase = (GamePhase)intPhase;
        }
        else if (intPhase == 3) {
            IncrementPlayerTurn(); // Move -> next player's turn
        }
        // ... special case handling for setup phases omitted
    }

    public void IncrementPlayerTurn()
    {
        // ... complex player validation and setup phase logic omitted
        int nextActive = NextActivePlayer();
        if (nextActive != -1) {
            PlayerTurn = nextActive;
            CurrentPhase = GamePhase.Place; // Start new turn
        }
    }

    // ... NextActivePlayer(), serialization methods, and other utilities omitted
}

// Regulator.cs - Event subscriber that enforces game rules
public class Regulator : IRegulator
{
    private readonly IGame _currentGame;
    private readonly StateMachine _machine;
    private readonly ILogger _logger; // ... other fields omitted
    private int _actionsCounter = 0;
    // ... _prevActionCount, CurrentActionsLimit properties omitted

    public event EventHandler<TerrID[]>? PromptBonusChoice;
    public event EventHandler<IPromptTradeEventArgs>? PromptTradeIn;

    public void Initialize()
    {
        // ... action limit initialization omitted
        // Subscribe to state changes - loose coupling via events
        _machine.StateChanged += HandleStateChanged;
    }

    // Event handler responds to state changes
    private void HandleStateChanged(object? sender, string propName)
    {
        if (propName != "CurrentPhase")
            return;

        // Each phase triggers different game logic
        switch (_machine.CurrentPhase) {
            case GamePhase.Place:
                // Update army pools and check for mandatory trades
                _currentGame.Players[_machine.PlayerTurn].ArmyPool += 
                    _currentGame.Players[_machine.PlayerTurn].ArmyBonus;
                
                if (_currentGame.Players[_machine.PlayerTurn].HasCardSet) {
                    bool force = _currentGame.Players[_machine.PlayerTurn].Hand.Count >= 5;
                    PromptTradeIn?.Invoke(this, new PromptTradeEventArgs(_machine.PlayerTurn, force));
                }
                break;

            case GamePhase.Attack:
                _machine.PhaseStageTwo = false;
                break;

            case GamePhase.Move:
                CurrentActionsLimit = _actionsCounter + 1;
                break;
        }
    }

    // Multi-stage action handling
    public (TerrID Selection, bool RequestInput, int? MaxValue) SelectTerritory(
        TerrID selected, TerrID priorSelected)
    {
        switch (_machine.CurrentPhase) {
            case GamePhase.Attack when !_machine.PhaseStageTwo:
                // Stage 1: Select attacking territory
                _machine.PhaseStageTwo = true;
                return (selected, false, null);
                
            case GamePhase.Attack when _machine.PhaseStageTwo:
                // Stage 2: Select target and request dice input
                _machine.PhaseStageTwo = false;
                return (selected, true, null);

            case GamePhase.Move when !_machine.PhaseStageTwo:
                // Stage 1: Select source territory
                _machine.PhaseStageTwo = true;
                return (selected, false, null);
                
            case GamePhase.Move when _machine.PhaseStageTwo:
                // Stage 2: Select destination and request army count
                _machine.PhaseStageTwo = false;
                int maxArmies = _currentGame.Board.Armies[priorSelected] - 1;
                return (TerrID.Null, true, maxArmies);

            default:
                // Single-stage actions (Place phase)
                ClaimOrReinforce(selected);
                return (TerrID.Null, false, null);
        }
    }

    // ... ClaimOrReinforce(), Battle(), TradeInCards() methods omitted

    private void IncrementAction()
    {
        _actionsCounter++;
        
        // ... ReachedSecondStage() logic omitted
        
        // Automatic progression when action limit reached
        if (_actionsCounter >= CurrentActionsLimit) {
            if (InSetupPhase)
                _machine.IncrementRound();
            else
                _machine.IncrementPhase(); // Triggers StateChanged event
        }
    }

    // ... validation methods, serialization, and other utilities omitted
}

// MainVM_Base.cs - ViewModel layer subscribes to events
public partial class MainVM_Base : ObservableObject, IMainVM
{
    // ... properties, commands, and other members omitted

    public void Initialize(string[] players, string[] colors, string? fileName)
    {
        // ... game creation and setup logic omitted
        
        // Event subscription creates loose coupling
        CurrentGame.State.StateChanged += HandleStateChanged;
        CurrentGame.Board.TerritoryChanged += HandleTerritoryChanged;
        Regulator.PromptBonusChoice += OnTerritoryBonusChoice;
        Regulator.PromptTradeIn += OnPromptTradeIn;
        
        // ... initialization of collections and UI state omitted
    }

    // UI responds to state changes without direct dependencies
    private void HandleStateChanged(object? sender, string propName)
    {
        switch (propName) {
            case nameof(CurrentPhase):
                CurrentPhase = CurrentGame.State.CurrentPhase;
                break;
            case nameof(PlayerTurn):
                PlayerTurn = CurrentGame.State.PlayerTurn;
                PlayerTurnChanging?.Invoke(this, PlayerTurn);
                break;
            // ... other property change handlers omitted
        }
    }
    
    // ... other event handlers and methods omitted
}
</code>
                </pre>
        </div>
    </div>
    <div class="code-with-text" id="RulesLogic">
        <div class="image-text">
            <h3>Declarative Rules Engine</h3>
            <p class="indented-p">A rules engine ("Regulator") enforces complex game mechanics. It:</p>
            <ul>
                <li><strong>Validates player actions</strong> based on current state, like game phase and player ownership</li>
                <li> <strong>Breaks complex operations</strong> into validated steps (attacks, moves)</li>
                <li> Systematically calculates and distributes resources (armies, bonuses, card rewards, etc)</li>
                <li> <strong>Responds to state changes</strong>, enforcing constraints without tight coupling</li>
            </ul>

            <p><center><i>Key Files: Regulator.cs, RuleValues.cs</i></center></p>
        </div>
        <div>
            <pre class="code-snippet">
            <code class="language-csharp">
public class Regulator : IRegulator
{
    private readonly IGame _currentGame;
    private readonly StateMachine _machine;
    private int _actionsCounter = 0;
    private int _prevActionCount = 0;

    public int CurrentActionsLimit { get; set; }
    public event EventHandler? PromptBonusChoice;
    public event EventHandler? PromptTradeIn;

    // Handle phase transitions
    private void HandleStateChanged(object? sender, string propName)
    {
        if (propName != "CurrentPhase") return;

        _prevActionCount = _actionsCounter;
        switch (_machine.CurrentPhase) {
            case GamePhase.Place:
                // Distribute army bonuses
                _currentGame.Players[_machine.PlayerTurn].ArmyPool += 
                    _currentGame.Players[_machine.PlayerTurn].ArmyBonus;
                CurrentActionsLimit = _actionsCounter + _currentGame.Players[_machine.PlayerTurn].ArmyPool;

                // Force trade if hand limit exceeded
                if (_currentGame.Players[_machine.PlayerTurn].HasCardSet) {
                    bool mandatoryTrade = _currentGame.Players[_machine.PlayerTurn].Hand.Count >= 5;
                    PromptTradeIn?.Invoke(this, new PromptTradeEventArgs(_machine.PlayerTurn, mandatoryTrade));
                }
                break;

            case GamePhase.Attack:
                _machine.PhaseStageTwo = false;
                break;

            case GamePhase.Move:
                CurrentActionsLimit = _actionsCounter + 1;
                break;
        }
    }

    // Validate territory selection
    public bool CanSelectTerritory(TerrID newSelected, TerrID oldSelected)
    {
        bool priorSelection = oldSelected != TerrID.Null;
        int owner = _currentGame.Board.TerritoryOwner[newSelected];
        int territoryArmies = _currentGame.Board.Armies[newSelected];

        return _machine.CurrentPhase switch {
            GamePhase.DefaultSetup => _machine.PhaseStageTwo switch {
                false when owner == -1 => true,                    // Claim unowned territory
                true when owner == _machine.PlayerTurn => true,    // Reinforce owned territory
                _ => false
            },

            GamePhase.Place => owner == _machine.PlayerTurn,

            // Attack requires two selections: source then target
            GamePhase.Attack when !priorSelection => 
                owner == _machine.PlayerTurn && territoryArmies >= 2,           // Select attacking territory
            GamePhase.Attack when priorSelection => 
                owner != _machine.PlayerTurn &&                                // Target enemy territory
                BoardGeography.GetNeighbors(oldSelected).Contains(newSelected), // Adjacent to source

            // Move requires two selections: source then destination  
            GamePhase.Move when !priorSelection => 
                owner == _machine.PlayerTurn && territoryArmies >= 2,           // Select source territory
            GamePhase.Move when priorSelection => 
                owner == _machine.PlayerTurn && oldSelected != newSelected &&  // Own destination, different from source
                IsConnectedPath(oldSelected, newSelected, _machine.PlayerTurn), // Connected through owned territories

            _ => false
        };
    }

    // Manage attack/move workflow
    public (TerrID Selection, bool RequestInput, int? MaxValue) SelectTerritory(TerrID selected, TerrID priorSelected)
    {
        switch (_machine.CurrentPhase) {
            case GamePhase.Attack when !_machine.PhaseStageTwo:
                // Store attacking territory, advance to target selection
                _machine.PhaseStageTwo = true;
                return (selected, false, null);
                
            case GamePhase.Attack when _machine.PhaseStageTwo:
                // Target selected, request dice allocation
                _machine.PhaseStageTwo = false;
                return (selected, true, null);

            case GamePhase.Move when !_machine.PhaseStageTwo:
                // Store source territory, advance to destination selection
                _machine.PhaseStageTwo = true;
                return (selected, false, null);
                
            case GamePhase.Move when _machine.PhaseStageTwo:
                // Destination selected, request army count
                _machine.PhaseStageTwo = false;
                int maxArmies = _currentGame.Board.Armies[priorSelected] - 1;
                return (TerrID.Null, true, maxArmies);

            default:
                // Single-stage actions (Place phase)
                ClaimOrReinforce(selected);
                return (TerrID.Null, false, null);
        }
    }

    // Resolve combat
    public void Battle(TerrID source, TerrID target, (int AttackRoll, int DefenseRoll)[] diceRolls)
    {
        _actionsCounter++;

        int sourceLoss = 0, targetLoss = 0;
        
        // Calculate casualties from dice results
        foreach (var (AttackRoll, DefenseRoll) in diceRolls) {
            if (AttackRoll > DefenseRoll) targetLoss++;
            else sourceLoss++;
        }

        // Handle territory conquest
        if (targetLoss >= _currentGame.Board.Armies[target]) {
            int conqueredOwner = _currentGame.Board.TerritoryOwner[target];
            int newOwner = _currentGame.Board.TerritoryOwner[source];
            
            // Transfer ownership
            if (conqueredOwner > -1)
                _currentGame.Players[conqueredOwner].RemoveTerritory(target);
            _currentGame.Players[newOwner].AddTerritory(target);

            _currentGame.Board.Conquer(source, target, newOwner);

            // Award conquest card
            Reward ??= _currentGame.Cards.GameDeck.DrawCard();
        }
        
        // Apply losses
        if (sourceLoss > 0) _currentGame.Board.Reinforce(source, -sourceLoss);
        if (targetLoss > 0) _currentGame.Board.Reinforce(target, -targetLoss);
    }

    // Process card trade-in
    public void TradeInCards(int playerNum, int[] handIndices)
    {
        var selectedCards = GetCardsFromHand(playerNum, handIndices);
        var currentPlayer = _currentGame.Players[playerNum];
        
        // Calculate escalating bonus
        _machine.IncrementNumTrades(1);
        int tradeBonus = _currentGame.Values.CalculateBaseTradeInBonus(_machine.NumTrades);
        
        // Apply bonus and discard cards
        currentPlayer.GetsTradeBonus(tradeBonus);
        CurrentActionsLimit += tradeBonus;
        ForceDiscard((Player)currentPlayer, handIndices);

        // Handle territory bonuses
        var tradedTargets = selectedCards.SelectMany(card => card.Target);
        var controlledTargets = currentPlayer.GetControlledTargets(tradedTargets.ToArray());
        
        if (controlledTargets.Length == 1)
            _currentGame.Board.Reinforce(controlledTargets[0], _currentGame.Values.TerritoryTradeInBonus);
        else if (controlledTargets.Length > 1)
            PromptBonusChoice?.Invoke(this, controlledTargets);
    }

    // Track actions and trigger phase progression
    private void IncrementAction()
    {
        _actionsCounter++;

        // Check for stage transitions
        if (ReachedSecondStage())
            _machine.PhaseStageTwo = true;

        // Trigger next phase when limit reached
        if (_actionsCounter >= CurrentActionsLimit) {
            if (InSetupPhase) _machine.IncrementRound();
            else _machine.IncrementPhase();
        }
    }

    // ... helper methods omitted
}
                    </code>
                </pre>
        </div>
    </div>
    <div class="code-with-text" id="Registry">
        <div class="image-text">
            <img src="Images/Registry.svg" />
            <h3>Team-Oriented Type Registry</h3>
            <p>Solves string-to-type resolution for binary deserialization while enabling iterative team development—built when TroopCard needed extension for MissionCard:</p>
            <ul>
                <li>Decouples type discovery from hardcoded references across application layers</li>
                <li>Enables data-driven initialization for different environments and test scenarios</li>
                <li>Validates type relationships automatically to catch integration errors early</li>
                <li>Provides consistent patterns for DAL, serialization, and factory components</li>
                <li>Supports adding new card types through configuration rather than code changes</li>
                <li>Creates clear extension points that junior developers can follow safely</li>
            </ul>
            <p><center><i>Key Files: TypeRegister.cs, TypeRelations.cs, RegistryInitializer.cs</i></center></p>
        </div>
        <div>
            <pre class="code-snippet">
            <code class="language-csharp">
// TypeRegister.cs - Extensible lookup system for team development
public class TypeRegister : ITypeRegister&lt;ITypeRelations&gt;
{
    private readonly Dictionary&lt;Type, ITypeRelations&gt; _typeRelata = [];

    public TypeRegister(IRegistryInitializer initializer)
    {
        initializer.PopulateRegistry(this);
    }

    // String-based type lookup for runtime resolution
    public Type? this[string lookupName] {
        get {
            if (string.IsNullOrEmpty(lookupName))
                return null;

            foreach (Type type in _typeRelata.Keys)
                if (_typeRelata[type][RegistryRelation.Name] is string registeredName 
                    && registeredName == lookupName)
                    return type;
            return null;
        }
    }
    
    // Type-based relationship lookup
    public ITypeRelations? this[Type type] {
        get {
            if (_typeRelata.TryGetValue(type, out ITypeRelations? relata))
                return _typeRelata[type];
            else return null;
        }
        set {
            if (value is ITypeRelations and not null)
                Register(type, value);
            else throw new ArgumentException($"{value} is not valid");
        }
    }
    
    // Relation-based reverse lookup across all types
    public (Type KeyType, object RelatedObject)[]? this[RegistryRelation relation] {
        get {
            List&lt;(Type, object)&gt; entries = [];
            foreach (Type type in _typeRelata.Keys) {
                if (_typeRelata[type][relation] != null) {
                    entries.Add(new(type, _typeRelata[type][relation]!));
                }
            }
            return entries.Count > 0 ? [.. entries] : null;
        }
    }

    // Validate parent-child type relationships with integrity checking
    public bool TryGetParentType(Type registeredType, out Type? parentType)
    {
        if (!_typeRelata.TryGetValue(registeredType, out ITypeRelations? relations)) {
            parentType = null;
            return false;
        }
        
        if (relations[RegistryRelation.CollectionType] is not Type collection) {
            parentType = null;
            return false;
        }
        
        // Verify bidirectional relationship integrity
        string? regCollectionName = relations[RegistryRelation.CollectionName] as string;
        if (regCollectionName != collection.Name)
            throw new InvalidDataException($"Collection name mismatch for {registeredType}");
            
        if (!_typeRelata.TryGetValue(collection, out ITypeRelations? collectionRelations))
            throw new InvalidDataException($"Parent collection {collection} not registered");
            
        if (collectionRelations[RegistryRelation.ElementType] is not Type elementType 
            || elementType != registeredType)
            throw new InvalidDataException($"Parent-child relationship broken");

        parentType = collection;
        return true;
    }

    // Reflection-based registration with default naming
    public void Register(Type type)
    {
        if (_typeRelata.ContainsKey(type))
            throw new ArgumentException($"{type} already registered");

        _typeRelata.Add(type, new TypeRelations([(type.Name, RegistryRelation.Name)]));
    }

    // ... other registration and management methods omitted
}

// TypeRelations.cs - Flexible object relationship container
public class TypeRelations : ITypeRelations
{
    private readonly Dictionary&lt;RegistryRelation, object&gt; _relatedObjects = [];

    public TypeRelations((object, RegistryRelation)[] relations)
    {
        foreach (var relation in relations)
            Add(relation.Item1, relation.Item2);
    }

    public object? this[RegistryRelation relation] {
        get {
            return _relatedObjects.TryGetValue(relation, out object? value) ? value : null;
        }
    }

    // Type-safe relationship validation
    public void Add(object obj, RegistryRelation relation)
    {
        if (_relatedObjects.ContainsKey(relation))
            throw new ArgumentException("Relation already exists");
            
        switch (relation) {
            case RegistryRelation.Name:
            case RegistryRelation.CollectionName:
            case RegistryRelation.DataFileName:
                if (obj is not string)
                    throw new ArgumentException($"{relation} requires string object");
                break;
                
            case RegistryRelation.CollectionType:
            case RegistryRelation.ElementType:
            case RegistryRelation.ConvertedDataType:
                if (obj is not Type)
                    throw new ArgumentException($"{relation} requires Type object");
                break;
                
            case RegistryRelation.DataConverter:
                if (!obj.GetType().IsClass)
                    throw new ArgumentException("DataConverter must be reference type");
                break;
                
            default:
                throw new ArgumentOutOfRangeException(nameof(relation));
        }
        
        _relatedObjects.Add(relation, obj);
    }

    // ... removal and utility methods omitted
}

// RegistryInitializer.cs - Data-driven type registration
public class RegistryInitializer(IOptions&lt;AppConfig&gt; options) : IRegistryInitializer
{
    private readonly CardRegistryRecord[] _cardTypeRegistryRecords = [
        new() {
            CardType = typeof(TroopCard),
            Name = nameof(TroopCard),
            CardSetType = typeof(TroopCardSet),
            SetName = nameof(TroopCardSet)
        }
    ];
    
    private readonly CardSetRegistryRecord[] _cardSetTypeRegistryRecords = [
        new() {
            CardSetType = typeof(TroopCardSet),
            Name = nameof(TroopCardSet),
            CardType = typeof(TroopCard),
            DataFileName = options.Value.DataFileMap[nameof(TroopCard) + "Set.json"],
            CardSetDataConverter = new TroopCardSetDataJConverter(),
            ConvertedDataType = typeof(TroopCardSet)
        }
    ];

    // Register types with full relationship metadata
    public void PopulateRegistry(ITypeRegister&lt;ITypeRelations&gt; registry)
    {
        RegisterGeography(registry);

        // Register card types with collection relationships
        foreach (var info in _cardTypeRegistryRecords) {
            TypeRelations cardRelations = new();
            cardRelations.Add(info.Name, RegistryRelation.Name);
            cardRelations.Add(info.CardSetType, RegistryRelation.CollectionType);
            cardRelations.Add(info.SetName, RegistryRelation.CollectionName);
            registry.Register(info.CardType, cardRelations);
        }

    // Register collection types with serialization metadata for DAL integration
    foreach (var info in _cardSetTypeRegistryRecords) {
        TypeRelations cardSetRelations = new();
        cardSetRelations.Add(info.Name, RegistryRelation.Name);
        cardSetRelations.Add(info.CardType, RegistryRelation.ElementType);
        cardSetRelations.Add(info.DataFileName, RegistryRelation.DataFileName);
        cardSetRelations.Add(info.CardSetDataConverter, RegistryRelation.DataConverter);
        cardSetRelations.Add(info.ConvertedDataType, RegistryRelation.ConvertedDataType);
        registry.Register(info.CardSetType, cardSetRelations);
    }
    }

    // ... geography registration and helper methods omitted
}
                    </code>
                </pre>
        </div>
    </div>

    <div class="code-with-text" id="Serializer">
        <div class="image-text">
            <img src="Images/Serializer.svg" />
            <h3>Custom Binary Serialization Framework</h3>
            <p>I implemented a robust binary serialization system that enables efficient game state persistence with full control over the serialization process:</p>
            <ul>
                <li>Type-safe encoding and decoding of complex objects</li>
                <li>Support for various data types including enums and collections</li>
                <li>Reflection-based property discovery with opt-in serialization</li>
                <li>Complete game state persistence with minimal overhead</li>
            </ul>
            <p>This system demonstrates understanding of low-level data structures, I/O operations, and efficient state management techniques.</p>
            <p><center><i>Key Files: BinarySerializer.cs, SerializedData.cs</i></center></p>
        </div>
        <div>
            <pre class="code-snippet">
public static class BinarySerializer
{
    public static async Task Save(IBinarySerializable[] serializableObjects, string fileName, bool newFile)
    {
        await Task.Run(() =>
        {
            if (newFile) {
                using FileStream fileStream = new(fileName, FileMode.Create, FileAccess.Write);
                using BinaryWriter writer = new(fileStream);

                foreach (var obj in serializableObjects)
                    try {
                        if (!WriteSerializableObject(obj, writer).Result)
                            _logger?.LogWarning("BinarySerializer failed to write {Object}.", obj);
                    } catch (Exception e) {
                        _logger?.LogError("An exception was thrown when attempting to write {obj}: {Message}.", obj, e.Message);
                    }
            }
            else {
                using FileStream fileStream = new(fileName, FileMode.Truncate, FileAccess.Write);
                using BinaryWriter writer = new(fileStream);

                foreach (var obj in serializableObjects)
                    try {
                        if (!WriteSerializableObject(obj, writer).Result)
                            _logger?.LogWarning("BinarySerializer failed to write {Object}.", obj);
                    } catch (Exception e) {
                        _logger?.LogError("An exception was thrown when attempting to write {obj}: {Message}.", obj, e.Message);
                    }
            }
        });
    }

    private static IConvertible BytesToConvertible(Type type, byte[] bytes)
    {
        if (type == typeof(byte) && bytes.Length == 1)
            return bytes[0];
        if (type == typeof(string))
            return Encoding.UTF8.GetString(bytes);
        if (type.IsEnum)
            return (IConvertible)Enum.ToObject(type, BitConverter.ToInt64(bytes, 0));

        double doubleVal = BitConverter.ToDouble(bytes, 0);
        return (IConvertible)Convert.ChangeType(doubleVal, type);
    }

    public static IConvertible ReadConvertible(BinaryReader reader, Type type)
    {
        int length = reader.ReadInt32();
        byte[] bytes = reader.ReadBytes(length);
        return BytesToConvertible(type, bytes);
    }
    
    public static Array ReadConvertibles(BinaryReader reader, Type type, int numValues)
    {
        if (!typeof(IConvertible).IsAssignableFrom(type) || type.IsEnum || type == typeof(string))
            throw new ArgumentException("ReadConvertibles accepts only IConvertible types, excluding strings and Enums.", nameof(type));

        Array returnArray = Array.CreateInstance(type, numValues);
        for (int i = 0; i < numValues; i++)
            returnArray.SetValue(ReadConvertible(reader, type), i);
        return returnArray;
    }
    
    private static async Task&lt;bool&gt; WriteSerializableObject(IBinarySerializable serializableObject, BinaryWriter writer)
    {
        try {
            if (await serializableObject.GetBinarySerials() is not SerializedData[] saveData) {
                _logger?.LogError("Failed: {object} did not return valid SerializedData[].", serializableObject);
                return false;
            }

            foreach (SerializedData saveDatum in saveData) {
                if (saveDatum.MemberType is not null) {
                    if (saveDatum.Tag != null)
                        WriteTaggedConvertibles(writer, saveDatum.MemberType, saveDatum.SerialValues, saveDatum.Tag);
                    else
                        WriteConvertibles(writer, saveDatum.MemberType, saveDatum.SerialValues);
                }
                else {
                    if (saveDatum.Tag != null)
                        WriteTaggedConvertible(writer, saveDatum.SerialType, saveDatum.SerialValues[0], saveDatum.Tag);
                    else
                        WriteConvertible(writer, saveDatum.SerialType, saveDatum.SerialValues[0]);
                }
            }
        } catch (Exception ex) {
            _logger?.LogError("{Message}.", ex.Message);
            return false;
        }
        return true;
    }
}
            </pre>
        </div>
    </div>



    <div class="code-with-text" id="GeographyGraph">
        <div class="image-text">
            <img src="Images/GeographyGraph.svg" />
            <h3>Configuration-Driven Spatial Graph</h3>
            <p>Bridges dynamic JSON configuration with type-safe spatial operations while providing foundation for extensible map systems:</p>
            <ul>
                <li>Resolves enum types dynamically from configuration while maintaining compile-time safety in core algorithms</li>
                <li>Pre-computes spatial relationships into immutable O(1) lookup structures for runtime performance</li>
                <li>Handles bidirectional territory-continent hierarchies with automatic integrity validation</li>
                <li>Enables complex spatial queries using efficient set operations</li>
                <li>Supports map layout variations through data files without code changes</li>
                <li>Provides architecture foundation that could extend to full assembly-based modding</li>
            </ul>
            <p><center><i>Key Files: BoardGeography.cs, GeographyInitializer.cs</i></center></p>
        </div>
        <div>
            <pre class="code-snippet">
            <code class="language-csharp">
// BoardGeography.cs - Immutable spatial relationship system
public static class BoardGeography
{
    private static ReadOnlyDictionary&lt;ContID, HashSet&lt;TerrID&gt;&gt;? _continentMembers;
    private static ReadOnlyDictionary&lt;TerrID, ContID&gt;? _terrIDToContID;
    private static ReadOnlyDictionary&lt;TerrID, HashSet&lt;TerrID&gt;&gt;? _neighborWeb;
    
    public static int NumTerritories { get; private set; }
    public static int NumContinents { get; private set; }
    
    // Data-driven initialization from JSON configuration
    public static void Initialize(GeographyInitializer initializer)
    {
        NumTerritories = initializer.TerritoryNames.Length - 1; // Account for Null values
        NumContinents = initializer.ContinentNames.Length - 1;

        Dictionary&lt;ContID, HashSet&lt;TerrID&gt;&gt; continentMembers = [];
        Dictionary&lt;TerrID, ContID&gt; terrIDToContID = [];
        Dictionary&lt;TerrID, HashSet&lt;TerrID&gt;&gt; neighborWeb = [];
        
        // Handle runtime type safety at configuration boundary
        foreach (var contTerrPair in initializer.ContinentMembers) {
            if (contTerrPair.Key is not ContID continent)
                continue;

            foreach (Enum territoryEnum in contTerrPair.Value) {
                if (territoryEnum is not TerrID territory)
                    continue;

                // Build continent membership maps
                if (!continentMembers.ContainsKey(continent))
                    continentMembers.Add(continent, []);

                continentMembers[continent].Add(territory);
                terrIDToContID[territory] = continent;
                
                // Initialize neighbor structure
                if (!neighborWeb.ContainsKey(territory))
                    neighborWeb.Add(territory, []);

                // Process adjacency relationships from configuration
                if (!initializer.TerritoryNeighbors.TryGetValue(territory, 
                       out HashSet&lt;Enum&gt;? neighbors) || neighbors == null)
                    continue;
                    
                foreach (Enum terrEnum in neighbors) {
                    if (terrEnum is not TerrID neighborTerritory)
                        continue;
                    neighborWeb[territory].Add(neighborTerritory);
                }
            }
        }
        
        // Create immutable collections for thread-safe access
        _continentMembers = new(continentMembers);
        _terrIDToContID = new(terrIDToContID);
        _neighborWeb = new(neighborWeb);
    }
    
    // O(1) continent lookup for territory ownership calculations
    public static ContID TerritoryToContinent(TerrID terrID)
    {
        if (_terrIDToContID == null) return ContID.Null;
        return _terrIDToContID.TryGetValue(terrID, out var continent) 
            ? continent : ContID.Null;
    }
    
    // Efficient continent membership queries
    public static HashSet&lt;TerrID&gt; GetContinentMembers(ContID continent)
    {
        if (_continentMembers == null) return [];
        return _continentMembers.TryGetValue(continent, out var members)
            ? members : [];
    }
    
    // Fast adjacency validation for move/attack legality
    public static HashSet&lt;TerrID&gt; GetNeighbors(TerrID territory)
    {
        if (_neighborWeb == null) return [];
        return _neighborWeb.TryGetValue(territory, out var neighbors) 
            ? neighbors : [];
    }
    
    // Complex spatial query using set operations
    public static bool IncludesContinent(HashSet&lt;TerrID&gt; territoryList, ContID continent)
    {
        if (_continentMembers == null) return false;
        if (!_continentMembers.TryGetValue(continent, out var continentMembers))
            return false;
        
        // Leverage HashSet.IsSubsetOf for efficient continent control validation
        return continentMembers.IsSubsetOf(territoryList);
    }
    
    // ... other spatial utilities omitted
}

// GeographyInitializer.cs - Flexible configuration processor
public class GeographyInitializer
{
    public Type? ContinentEnumType { get; set; }
    public Type? TerritoryEnumType { get; set; }
    public string[] ContinentNames { get; private set; } = [];
    public string[] TerritoryNames { get; private set; } = [];
    public Dictionary&lt;Enum, HashSet&lt;Enum&gt;&gt; ContinentMembers { get; } = [];
    public Dictionary&lt;Enum, HashSet&lt;Enum&gt;&gt; TerritoryNeighbors { get; } = [];
    
    // Runtime type resolution bridges JSON config with compile-time type safety
    public void SetEnumTypes((string ContinentEnumName, string TerritoryEnumName) names)
    {
        // Resolve enum types dynamically from configuration strings
        if (Type.GetType(names.ContinentEnumName) is not Type continentEnumType || !continentEnumType.IsEnum)
            throw new InvalidDataException($"Could not locate Continent Enum: {names.ContinentEnumName}");
        ContinentEnumType = continentEnumType;
        
        if (Type.GetType(names.TerritoryEnumName) is not Type territoryEnumType || !territoryEnumType.IsEnum)
            throw new InvalidDataException($"Could not locate Territory Enum: {names.TerritoryEnumName}");
        TerritoryEnumType = territoryEnumType;

        ContinentNames = Enum.GetNames(ContinentEnumType);
        TerritoryNames = Enum.GetNames(TerritoryEnumType);
    }
    
    // Validate types at configuration boundary, maintain safety in core operations
    public bool AddContinentMember(string continentName, string territoryName)
    {
        if (ContinentEnumType == null || TerritoryEnumType == null)
            return false;
            
        // Type validation happens once during configuration loading
        if (Enum.Parse(ContinentEnumType, continentName) is not Enum continentEnum)
            return false;
        if (Enum.Parse(TerritoryEnumType, territoryName) is not Enum territoryEnum)
            return false;
            
        try {
            if (!ContinentMembers.ContainsKey(continentEnum))
                ContinentMembers.Add(continentEnum, []);

            ContinentMembers[continentEnum].Add(territoryEnum);
        } catch {
            return false;
        }
        return true;
    }
    
    // Bidirectional neighbor relationship management
    public bool AddTerritoryNeighbor(string territoryName, string neighborName)
    {
        if (TerritoryEnumType == null)
            return false;
            
        if (Enum.Parse(TerritoryEnumType, territoryName) is not Enum territoryEnum)
            return false;
        if (Enum.Parse(TerritoryEnumType, neighborName) is not Enum neighborEnum)
            return false;
            
        try {
            if (!TerritoryNeighbors.ContainsKey(territoryEnum))
                TerritoryNeighbors.Add(territoryEnum, []);

            TerritoryNeighbors[territoryEnum].Add(neighborEnum);
        } catch {
            return false;
        }
        return true;
    }
    
    // ... other configuration methods omitted
}

// EarthBoard.cs - Geography integration example
public class EarthBoard : IBoard
{
    // Efficient continent control detection using geography system
    public void CheckContinentFlip(TerrID changed, int previousOwner)
    {
        int newOwner = TerritoryOwner[changed];
        var changedHomeContinent = BoardGeography.TerritoryToContinent(changed);
        var continentTerritories = BoardGeography.GetContinentMembers(changedHomeContinent);
        
        if (continentTerritories.Count <= 0) return;

        // Use geography system for ownership validation
        if (ContinentOwner[changedHomeContinent] == previousOwner && previousOwner > -1) {
            ContinentOwner[changedHomeContinent] = -1;
            
            // Efficient "all territories owned by same player" check
            if (continentTerritories.All(terr => TerritoryOwner[terr] == newOwner))
                ContinentOwner[changedHomeContinent] = newOwner;

            ContinentOwnerChanged?.Invoke(this, 
                new ContinentOwnerChangedEventArgs(changedHomeContinent, previousOwner));
        }
        else if (continentTerritories.All(terr => TerritoryOwner[terr] == newOwner)) {
            ContinentOwner[changedHomeContinent] = newOwner;
            ContinentOwnerChanged?.Invoke(this, 
                new ContinentOwnerChangedEventArgs(changedHomeContinent, previousOwner));
        }
    }
    
    // ... other board methods omitted
}
            </code>
            </pre>
        </div>
    </div>

    <div class="code-with-text" id="DefaultPrototyping">
        <div class="image-text">
            <img src="Images/PrototypingWithReflection.svg" />
            <h3>Reflection-Based Rapid Prototyping</h3>
            <p>Built on registry and serialization systems to eliminate implementation friction for team members experimenting with new card types:</p>
            <ul>
                <li>Uses C# 8.0+ default interface methods to provide automatic serialization</li>
                <li>Eliminates boilerplate for developers adding experimental card implementations</li>
                <li>Handles complex reflection logic once rather than per-implementation</li>
                <li>Provides consistent serialization behavior across all card types</li>
                <li>Includes clear migration path from prototype to optimized production code</li>
                <li>Reduces cognitive load during rapid iteration and experimentation phases</li>
            </ul>
            <p><center><i>Key Files: ICard.cs, TroopCard.cs, CardBase.cs</i></center></p>
        </div>
        <div>
            <pre class="code-snippet">
            <code class="language-csharp">
// ICard.cs - Default interface methods for rapid prototyping
public interface ICard : IBinarySerializable
{
    #region Properties
    ILogger Logger { get; set; }
    /// <summary>
    /// Property names for automatic serialization via reflection.
    /// Developers specify what to serialize; interface handles how.
    /// </summary>
    HashSet&lt;string&gt; SerializablePropertyNames { get; }
    string TypeName { get; set; }
    string ParentTypeName { get; }
    ICardSet? CardSet { get; set; }
    TerrID[] Target { get; set; }
    bool IsTradeable { get; set; }
    #endregion

    // Default implementation eliminates serialization boilerplate
    async Task&lt;SerializedData[]&gt; IBinarySerializable.GetBinarySerials()
    {
        return await Task.Run(() =&gt;
        {
            Type instanceType = this.GetType();
            PropertyInfo[] instanceProperties = instanceType.GetProperties();
            var orderedProperties = instanceProperties.OrderBy(property =&gt; property.Name);

            List&lt;SerializedData&gt; serialData = [];
            
            // Type name for registry lookup during deserialization
            serialData.Add(new SerializedData(typeof(int), SerializablePropertyNames.Count, instanceType.Name));
            
            foreach (PropertyInfo propInfo in orderedProperties) {
                string propName = propInfo.Name;
                Type propType = propInfo.PropertyType;
                
                if (!SerializablePropertyNames.Contains(propName))
                    continue;
                    
                if (!BinarySerializer.IsSerializable(propType)) {
                    Logger.LogWarning("{Card} property {Name} not serializable.", this, propName);
                    continue;
                }
                
                if (propInfo.GetValue(this) is not object propValue)
                    continue;

                // Handle both single values and collections automatically
                IConvertible[] propConvertibles = new IConvertible[1];
                if (typeof(IEnumerable).IsAssignableFrom(propType) && propType != typeof(string)) {
                    propConvertibles = BinarySerializer.ToIConvertibleCollection((IEnumerable)propValue);
                }
                else {
                    propConvertibles[0] = (IConvertible)propValue;
                }

                serialData.Add(new SerializedData(typeof(int), propConvertibles.Length));
                serialData.Add(new SerializedData(propType, [.. propConvertibles], propInfo.Name));
            }
            
            return serialData.ToArray();
        });
    }

    // Default deserialization with property matching validation
    bool IBinarySerializable.LoadFromBinary(BinaryReader reader)
    {
        bool loadComplete = true;
        try {
            var cardProps = this.GetType().GetProperties();
            int loadedNumProperties = (int)BinarySerializer.ReadConvertible(reader, typeof(int));

            // Validate property count matches expectations
            if (loadedNumProperties != SerializablePropertyNames.Count)
                return false;
                
            var propertyNames = cardProps.Select(prop =&gt; prop.Name);
            var matchingNames = propertyNames.Intersect(SerializablePropertyNames);
            var orderedMatchNames = matchingNames.OrderBy(name =&gt; name).ToHashSet();

            // Process each serialized property in alphabetical order
            foreach (string propName in orderedMatchNames) {
                int numValues = (int)BinarySerializer.ReadConvertible(reader, typeof(int));
                string readPropName = reader.ReadString();
                
                if (readPropName != propName) {
                    Logger.LogError("{Card} property name mismatch during load.", this);
                    return false;
                }
                
                var matchingProperty = cardProps.Where(prop =&gt; prop.Name == readPropName).FirstOrDefault();
                if (matchingProperty == null) {
                    Logger.LogError("{Card} property {name} not found during load.", this, readPropName);
                    return false;
                }

                Type propType = matchingProperty.PropertyType;
                
                // Handle arrays and single values with appropriate deserializers
                if (!propType.IsArray) {
                    matchingProperty.SetValue(this, BinarySerializer.ReadConvertible(reader, propType));
                }
                else {
                    Type? elementType = propType.GetElementType();
                    if (elementType == null) {
                        Logger.LogError("{Card} array property {name} missing element type.", this, propName);
                        return false;
                    }
                    
                    if (elementType.IsEnum)
                        matchingProperty.SetValue(this, BinarySerializer.ReadEnums(reader, elementType, numValues));
                    else if (elementType == typeof(string))
                        matchingProperty.SetValue(this, BinarySerializer.ReadStrings(reader, numValues));
                    else
                        matchingProperty.SetValue(this, BinarySerializer.ReadConvertibles(reader, elementType, numValues));
                }
            }
        } catch (Exception ex) {
            Logger.LogError("Exception loading {Card}: {Message}", this, ex.Message);
            loadComplete = false;
        }
        
        return loadComplete;
    }
}

// Example Usage - Minimal implementation for rapid experimentation
public class MissionCard : ICard
{
    public ILogger Logger { get; set; } = null!;
    
    // Declarative serialization - specify what, not how
    public HashSet&lt;string&gt; SerializablePropertyNames { get; } = 
        [nameof(MissionType), nameof(Reward), nameof(Target), nameof(IsTradeable)];
    
    public string TypeName { get; set; } = nameof(MissionCard);
    public string ParentTypeName =&gt; nameof(MissionCardSet);
    public ICardSet? CardSet { get; set; }
    
    // Card-specific properties
    public string MissionType { get; set; } = string.Empty;
    public int Reward { get; set; }
    public TerrID[] Target { get; set; } = [];
    public bool IsTradeable { get; set; } = true;
    
    // Serialization happens automatically via interface defaults
    // Override with custom implementation when performance becomes critical
}

// Production example - Custom serialization for performance-critical scenarios
public class TroopCard : ICard
{
    // ... properties omitted for brevity
    
    // Override default with optimized implementation
    async Task&lt;SerializedData[]&gt; IBinarySerializable.GetBinarySerials()
    {
        // Custom, high-performance serialization logic
        // Avoids reflection overhead for production scenarios
        return await Task.Run(() =&gt; [
            new SerializedData(typeof(string), [TypeName]),
            new SerializedData(typeof(TerrID), Target.Cast&lt;IConvertible&gt;().ToArray()),
            new SerializedData(typeof(bool), [IsTradeable])
        ]);
    }
    
    // ... custom LoadFromBinary implementation omitted
}
                    </code>
                </pre>
        </div>
    </div>

    <div class="presentation-box">
        <h3 style="color: #31c1cc;">Technical Skills Developed</h3>
        <ul class="skills-list">
            <li>Advanced C# programming techniques</li>
            <li>Object-oriented design</li>
            <li>Applying SOLID</li>
            <li>Event-driven architecture</li>
            <li>State management</li>
            <li>Domain-driven design</li>
            <li>Custom serialization</li>
            <li>Binary serialization</li>
            <li>Reflection and meta-programming</li>
            <li>Error handling and logging</li>
            <li>Clean code architecture</li>
            <li>XML documentation</li>
            <li>Asynchronous programming</li>
            <li>WPF UI design</li>
        </ul>
        <p style="margin-top: 1em;">These software engineering skills transfer directly to enterprise application development, and demonstrate my capability for building complex, maintainable systems.</p>
    </div>

    <div class="call-to-action">
        <h2>Discuss My Work</h2>
        <p>I'd be happy to walk through any aspect of this project in detail, including technical decisions and implementation patterns.</p>
        <p>Contact me to schedule a conversation about how these skills can benefit your development team!</p>
        <div class="button-container">
            <a href="mailto:joshua.a.mcknight@gmail.com" class="cta-button">Contact Me</a>
            <a href="https://github.com/LivingCryogen/Hazard" class="cta-button">View on GitHub</a>
        </div>
    </div>
</body>
</html>