using Hazard_Share.Interfaces.Model;

namespace Hazard_Model.Entities;
/// <summary>
/// Represents a Deck of cards. Each card targets at minimum one Territory <see cref="ICard"/>.
/// </summary>
public class Deck 
{
    /// <summary>
    /// Constructs an empty Deck.
    /// </summary>
    public Deck()
    {
        Library = [];
        DiscardPile = [];
    }
    /// <summary>
    /// Constructs a Deck from a group of cards, placing them all in the <see cref="Library"/>.
    /// </summary>
    /// <param name="cards">An array of <see cref="ICard"/>s that will constitute the deck.</param>
    public Deck(ICard[] cards)
    {
        Library = [.. cards];
        DiscardPile = [];
    }
    /// <remarks>
    /// This constructor is useful when a <see cref="Deck"/> is to be built from multiple <see cref="ICardSet.Cards"/> values.
    /// </remarks>
    /// <param name="cards">An array of <see cref="ICard"/> arrays whose contents that will constitute the deck.</param>
    /// <inheritdoc cref="Deck(ICard[])"/>
    public Deck(ICard[][] cards)
    {
        Library = [.. cards.SelectMany(set => set.Select(card => card))];
        DiscardPile = [];
    }
    /// <param name="cardSet">An <see cref="ICardSet"/> whose property <see cref="ICardSet.Cards"/> contains the <see cref="ICard"/>s that will constitute the deck.</param>
    /// <inheritdoc cref="Deck(ICard[])"/>
    public Deck(ICardSet cardSet)
    {
        Library = [.. cardSet?.Cards ?? Enumerable.Empty<ICard>()];
        DiscardPile = [];
    }
    /// <param name="cardSets">An array of <see cref="ICardSet"/>s, each of whose property <see cref="ICardSet.Cards"/> contains <see cref="ICard"/>s that will constitute the deck.</param>
    /// <inheritdoc cref="Deck(ICard[])"/>
    public Deck(ICardSet[] cardSets)
    {
        Library = [.. cardSets?.SelectMany(item => (item?.Cards ?? Enumerable.Empty<ICard>()))];
        DiscardPile = [];
    }
    /// <summary>
    /// Gets or sets the library of the <see cref="Deck"/>.
    /// </summary>
    /// <remarks>
    /// A library is the collection of cards from which players draw (see <see cref="DrawCard"/>).
    /// </remarks>
    /// <value>
    /// A <see cref="List{T}"/> of <see cref="ICard"/>.
    /// </value>
    public List<ICard> Library { get; set; }
    /// <summary>
    /// Gets or sets the discard pile of the <see cref="Deck"/>.
    /// </summary>
    /// <remarks>
    /// A discard pile is the collection of cards to which cards are discarded when traded in (see <see cref="Discard(ICard)"/> and <see cref="IRegulator.TradeInCards(int, int[])"/>).
    /// </remarks>
    /// <value>
    /// A <see cref="List{T}"/> of <see cref="ICard"/>.
    /// </value>
    public List<ICard> DiscardPile { get; set; }
    /// <summary>
    /// Draws a card from the bottom of the <see cref="Library"/>.
    /// </summary>
    /// <remarks>
    /// If <see cref="Library"/> is empty, <see cref="Shuffle"/> is called.
    /// </remarks>
    /// <returns>An <see cref="ICard"/>.</returns>
    public ICard DrawCard()
    {
        if (Library.Count + DiscardPile.Count <= 0)
            throw new InvalidOperationException("An attempt was made to draw a card from an empty deck.");
        if (Library.Count <= 0)
            Shuffle();

        ICard drawn = Library[^1];
        Library.Remove(Library[^1]);
        return drawn;
    }
    /// <summary>
    /// Adds a card to the discard pile.
    /// </summary>
    /// <param name="card">The discarded <see cref="ICard"/>.</param>
    public void Discard(ICard card)
    {
        DiscardPile.Add(card);
    }
    /// <summary>
    /// Adds a collection of cards to the discard pile.
    /// </summary>
    /// <param name="cards">The discardeds <see cref="ICard"/>.</param>
    public void Discard(ICard[] cards)
    {
        DiscardPile.AddRange(cards);
    }
    /// <summary>
    /// Shuffles the <see cref="Deck"/>.
    /// </summary>
    /// <remarks>
    /// Resulting <see cref="Library"/> order is generated by a Fisher-Yates shuffle algorithm. 
    /// </remarks>
    public void Shuffle()
    {
        if (DiscardPile.Count > 0) {
            Library.AddRange(DiscardPile);
            DiscardPile.Clear();
        }
        if (Library.Count <= 0)
            return;

        Random randGen = new();
        for (int i = Library.Count - 1; i >= 1; i--) {
            int j = randGen.Next(0, i + 1);
            (Library[j], Library[i]) = (Library[i], Library[j]);
        }
    }
}
