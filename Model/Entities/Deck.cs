using Shared.Interfaces.Model;

namespace Model.Entities;
/// <summary>
/// A deck of cards.
/// </summary>
/// <remarks>
/// Each <see cref="ICard">card</see> targets at minimum one territory: see <see cref="ICard.Target"/>.
/// </remarks>
public class Deck
{
    /// <summary>
    /// Constructs an empty deck.
    /// </summary>
    public Deck()
    {
        Library = [];
        DiscardPile = [];
    }
    /// <summary>
    /// Constructs a deck from a group of cards, placing them all in the <see cref="Library"/>.
    /// </summary>
    /// <param name="cards">The cards that will constitute the deck.</param>
    public Deck(ICard[] cards)
    {
        Library = [.. cards];
        DiscardPile = [];
    }
    /// <remarks>
    /// This constructor is useful when a <see cref="Deck"/> is to be built from multiple <see cref="ICardSet.Cards"/> values.
    /// </remarks>
    /// <param name="cards">A staggered array of cards that will constitute the deck.</param>
    /// <inheritdoc cref="Deck(ICard[])"/>
    public Deck(ICard[][] cards)
    {
        Library = [.. cards.SelectMany(set => set.Select(card => card))];
        DiscardPile = [];
    }
    /// <param name="cardSet">A card set, whose property <see cref="ICardSet.Cards"/> contains the <see cref="ICard"/>s that will constitute the deck.</param>
    /// <inheritdoc cref="Deck(ICard[])"/>
    public Deck(ICardSet cardSet)
    {
        Library = [.. cardSet?.Cards ?? Enumerable.Empty<ICard>()];
        DiscardPile = [];
    }
    /// <param name="cardSets">An array of card sets, each of whose property <see cref="ICardSet.Cards"/> contains <see cref="ICard"/>s that will constitute the deck.</param>
    /// <inheritdoc cref="Deck(ICard[])"/>
    public Deck(ICardSet[] cardSets)
    {
        Library =
            [..
                cardSets?.SelectMany(item =>
                    (item?.Cards ?? Enumerable.Empty<ICard>()))
                ??
                []
            ];
        DiscardPile = [];
    }
    /// <summary>
    /// Gets or sets the library.
    /// </summary>
    /// <remarks>
    /// A library is the collection of cards from which players draw (see <see cref="DrawCard"/>).
    /// </remarks>
    public List<ICard> Library { get; set; }
    /// <summary>
    /// Gets or sets the discard pile.
    /// </summary>
    /// <remarks>
    /// A discard pile is the collection to which cards are discarded when traded in; see <see cref="Discard(ICard)"/> and <see cref="IRegulator.TradeInCards(int, int[])"/>.
    /// </remarks>
    public List<ICard> DiscardPile { get; set; }
    /// <summary>
    /// Draws a card from the bottom of the <see cref="Library"/>.
    /// </summary>
    /// <remarks>
    /// If <see cref="Library"/> is empty, <see cref="Shuffle"/> is called.
    /// </remarks>
    /// <returns>The drawn card.</returns>
    public ICard DrawCard()
    {
        if (Library.Count + DiscardPile.Count <= 0)
            throw new InvalidOperationException("An attempt was made to draw a card from an empty deck.");
        if (Library.Count <= 0)
            Shuffle();

        ICard drawn = Library[^1];
        Library.Remove(Library[^1]);
        return drawn;
    }
    /// <summary>
    /// Adds a card to the discard pile.
    /// </summary>
    /// <param name="card">The discarded card.</param>
    public void Discard(ICard card)
    {
        DiscardPile.Add(card);
    }
    /// <summary>
    /// Adds a collection of cards to the discard pile.
    /// </summary>
    /// <param name="cards">The discarded cards.</param>
    public void Discard(ICard[] cards)
    {
        DiscardPile.AddRange(cards);
    }
    /// <summary>
    /// Shuffles the deck.
    /// </summary>
    /// <remarks>
    /// Resulting <see cref="Library"/> order is generated by a Fisher-Yates shuffle algorithm. 
    /// </remarks>
    public void Shuffle()
    {
        if (DiscardPile.Count > 0) {
            Library.AddRange(DiscardPile);
            DiscardPile.Clear();
        }
        if (Library.Count <= 0)
            return;

        Random randGen = new();
        for (int i = Library.Count - 1; i >= 1; i--) {
            int j = randGen.Next(0, i + 1);
            (Library[j], Library[i]) = (Library[i], Library[j]);
        }
    }
}
