# .NET Desktop MSIX packaging pipeline with separate stages for build types
trigger: none

variables:
  solution: '**/*.sln'
  buildPlatform: 'x64'
  buildConfiguration: 'Release'
  storageAccount: 'jm84storage'
  containerName: 'hazard'

stages:
# Framework-Dependent Build and Deployment
- stage: FrameworkDependent
  displayName: 'Framework-Dependent Build'
  variables:
    publishPath: '$(Build.ArtifactStagingDirectory)\publish\framework-dependent'
    msixOutputPath: '$(Build.ArtifactStagingDirectory)\msix\framework-dependent'
    blobPath: 'framework-dependent'
  jobs:
  - job: Build
    pool:
      vmImage: 'windows-latest'
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.0.x'
        includePreviewVersions: false

    # NuGet installation and restore with explicit runtime
    - task: NuGetToolInstaller@1
      displayName: Install NuGet

    - task: NuGetCommand@2
      displayName: Restore NuGet Packages
      inputs:
        command: 'restore'
        restoreSolution: '$(solution)'
        
    # Explicitly set Windows App SDK references if needed
    - task: PowerShell@2
      displayName: 'Check Windows App SDK installation'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Checking if Windows App SDK is properly referenced..."
          Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "*.csproj" -Recurse | ForEach-Object {
            $content = Get-Content $_.FullName -Raw
            Write-Host "Project file: $($_.FullName)"
            if ($content -match "Microsoft.WindowsAppSDK") {
              Write-Host "Windows App SDK reference found"
            } else {
              Write-Host "No Windows App SDK reference found in this project"
            }
          }

    # Explicitly restore runtime packs for win-x64
    - task: DotNetCoreCLI@2
      displayName: 'Install Required Runtime Packs'
      inputs:
        command: 'custom'
        custom: 'workload'
        arguments: 'install wasm-tools'

    - task: DotNetCoreCLI@2
      displayName: '.NET Restore With Runtime Pack'
      inputs:
        command: 'restore'
        projects: '$(solution)'
        feedsToUse: 'select'
        
    # Explicitly install win-x64 runtime
    - task: PowerShell@2
      displayName: 'Explicitly Install Runtime Packs'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing required runtime packs..."
          dotnet add package Microsoft.NETCore.App.Runtime.win-x64 --version 8.0.0
          dotnet add package Microsoft.WindowsDesktop.App.Runtime.win-x64 --version 8.0.0
          
          # Force restore with runtime identifier
          dotnet restore --runtime win-x64

    # Cache NuGet packages
    - task: Cache@2
      displayName: 'Cache NuGet packages'
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/*.csproj'
        restoreKeys: |
          nuget | "$(Agent.OS)"
        path: $(Pipeline.Workspace)/.nuget/packages
        cacheHitVar: 'CACHE_RESTORED'

    # Build with explicit platform and RID settings - two-step approach
    - task: DotNetCoreCLI@2
      displayName: 'Publish .NET Project with Runtime'
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: '**/Bootstrap.csproj'
        arguments: '--configuration $(buildConfiguration) --runtime win-x64 --self-contained false -p:PublishSingleFile=false -p:PublishReadyToRun=false'
        zipAfterPublish: false
        modifyOutputPath: true

    # Now build the MSIX package
    - task: VSBuild@1
      displayName: 'Build Framework-Dependent MSIX'
      inputs:
        solution: '$(solution)'
        platform: '$(buildPlatform)'
        configuration: '$(buildConfiguration)'
        msbuildArgs: '/p:RuntimeIdentifier=win-x64 /p:AppxPackageDir="$(msixOutputPath)\\" /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundlePlatforms="$(buildPlatform)" /p:AppxBundle=Always /p:GenerateAppInstaller=True /p:AppxPackageSigningEnabled=False /p:SelfContained=false'

    # Verify MSIX creation success
    - task: PowerShell@2
      displayName: 'Verify MSIX Package'
      inputs:
        targetType: 'inline'
        script: |
          $msixPath = "$(msixOutputPath)"
          Write-Host "Checking for MSIX packages in: $msixPath"
          $msixFiles = Get-ChildItem -Path $msixPath -Filter "*.msix*" -Recurse
          
          if ($msixFiles.Count -eq 0) {
            Write-Host "##vso[task.logissue type=warning]No MSIX packages found!"
          } else {
            foreach ($file in $msixFiles) {
              Write-Host "Found MSIX package: $($file.FullName)"
            }
          }

    - task: CopyFiles@2
      displayName: 'Copy MSIX package to publish directory'
      inputs:
        SourceFolder: '$(msixOutputPath)'
        Contents: '**/*.msix*'
        TargetFolder: '$(publishPath)'
        CleanTargetFolder: false
        OverWrite: true

    - task: AzureCLI@2
      displayName: 'Azure CLI'
      inputs:
        azureSubscription: 'JoshMcKnight Azure TopLevel'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "##vso[task.setvariable variable=ARM_CLIENT_ID;issecret=true]$servicePrincipalId" 
          echo "##vso[task.setvariable variable=ARM_ID_TOKEN;issecret=true]$idToken"
          echo "##vso[task.setvariable variable=ARM_TENANT_ID;issecret=true]$tenantId"
        addSpnToEnvironment: true

    - bash: |
        az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
      displayName: 'Azure Login'

    - task: TrustedSigning@0
      displayName: 'Sign with Trusted Signing'
      inputs:
        Endpoint: 'https://eus.codesigning.azure.net/'
        TrustedSigningAccountName: 'joshmcknightsigning'
        CertificateProfileName: 'JoshuaMcKnight'
        FilesFolder: '$(publishPath)'
        ExcludeEnvironmentCredential: true
        ExcludeWorkloadIdentityCredential: true
        ExcludeManagedIdentityCredential: true
        ExcludeSharedTokenCacheCredential: true
        ExcludeVisualStudioCredential: true
        ExcludeVisualStudioCodeCredential: true
        ExcludeAzureCliCredential: false
        ExcludeAzurePowershellCredential: true
        ExcludeAzureDeveloperCliCredential: true
        ExcludeInteractiveBrowserCredential: true

    - task: AzureCLI@2
      displayName: 'Copy to Blob Storage and Set Content Types'
      inputs:
        azureSubscription: 'JoshMcKnight Azure TopLevel'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Upload using the service principal auth with overwrite
          az storage blob upload-batch `
            --source "$(publishPath)" `
            --destination "$(containerName)" `
            --destination-path "$(blobPath)" `
            --account-name "$(storageAccount)" `
            --auth-mode login `
            --overwrite $true

          # Set content type for MSIX package
          az storage blob update `
            --container-name "$(containerName)" `
            --name "$(blobPath)/Hazard.msix" `
            --content-type "application/vnd.ms-appx" `
            --account-name "$(storageAccount)" `
            --auth-mode login
# Self-Contained Build and Deployment
- stage: SelfContained
  displayName: 'Self-Contained Build'
  variables:
    publishPath: '$(Build.ArtifactStagingDirectory)\publish\self-contained'
    msixOutputPath: '$(Build.ArtifactStagingDirectory)\msix\self-contained'
    blobPath: 'self-contained'
  jobs:
  - job: Build
    pool:
      vmImage: 'windows-latest'
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.0.x'
        includePreviewVersions: false

# Nuget Restore needed to properly handle Windows Runtime (for whatever reason)
    - task: NuGetToolInstaller@1
      displayName: Install NuGet

    - task: NuGetCommand@2
      displayName: Restore NuGet Packages
      inputs:
        command: 'restore'
        restoreSolution: '**/*.sln' # Replace with the path to your solution file
        arguments: '-RuntimeIdentifier win-x64' # Add the runtime identifier argument
    # Standard restore command
    - task: DotNetCoreCLI@2
      inputs:
        command: 'restore'
        projects: '$(solution)'
        feedsToUse: 'select'
        arguments: '--runtime win-x64'

    - task: Cache@2
      displayName: 'Cache NuGet packages'
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/*.csproj'
        restoreKeys: |
          nuget | "$(Agent.OS)"
        path: $(Pipeline.Workspace)/.nuget/packages
        cacheHitVar: 'CACHE_RESTORED'

    - task: VSBuild@1
      displayName: 'Build Self-Contained MSIX'
      inputs:
        solution: '$(solution)'
        platform: '$(buildPlatform)'
        configuration: '$(buildConfiguration)'
        msbuildArgs: '/p:AppxPackageDir="$(msixOutputPath)\\" /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundlePlatforms="$(buildPlatform)" /p:AppxBundle=Always /p:GenerateAppInstaller=True /p:AppxPackageSigningEnabled=False /p:SelfContained=true'

    - task: CopyFiles@2
      displayName: 'Copy MSIX package to publish directory'
      inputs:
        SourceFolder: '$(msixOutputPath)'
        Contents: '**/*.msix*'
        TargetFolder: '$(publishPath)'
        CleanTargetFolder: false
        OverWrite: true

    - task: AzureCLI@2
      displayName: 'Azure CLI'
      inputs:
        azureSubscription: 'JoshMcKnight Azure TopLevel'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "##vso[task.setvariable variable=ARM_CLIENT_ID;issecret=true]$servicePrincipalId" 
          echo "##vso[task.setvariable variable=ARM_ID_TOKEN;issecret=true]$idToken"
          echo "##vso[task.setvariable variable=ARM_TENANT_ID;issecret=true]$tenantId"
        addSpnToEnvironment: true

    - bash: |
        az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
      displayName: 'Azure Login'
    - task: TrustedSigning@0
      displayName: 'Sign with Trusted Signing'
      inputs:
        Endpoint: 'https://eus.codesigning.azure.net/'
        TrustedSigningAccountName: 'joshmcknightsigning'
        CertificateProfileName: 'JoshuaMcKnight'
        FilesFolder: '$(publishPath)'
        ExcludeEnvironmentCredential: true
        ExcludeWorkloadIdentityCredential: true
        ExcludeManagedIdentityCredential: true
        ExcludeSharedTokenCacheCredential: true
        ExcludeVisualStudioCredential: true
        ExcludeVisualStudioCodeCredential: true
        ExcludeAzureCliCredential: false
        ExcludeAzurePowershellCredential: true
        ExcludeAzureDeveloperCliCredential: true
        ExcludeInteractiveBrowserCredential: true

    - task: AzureCLI@2
      displayName: 'Copy to Blob Storage and Set Content Types'
      inputs:
        azureSubscription: 'JoshMcKnight Azure TopLevel'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Upload using the service principal auth with overwrite
          az storage blob upload-batch `
            --source "$(publishPath)" `
            --destination "$(containerName)" `
            --destination-path "$(blobPath)" `
            --account-name "$(storageAccount)" `
            --auth-mode login `
            --overwrite $true

          # Set content type for MSIX package
          az storage blob update `
            --container-name "$(containerName)" `
            --name "$(blobPath)/Hazard.msix" `
            --content-type "application/vnd.ms-appx" `
            --account-name "$(storageAccount)" `
            --auth-mode login